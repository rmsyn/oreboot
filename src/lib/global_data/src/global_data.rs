use alloc::collections::LinkedList;
use core::ptr::NonNull;
use crate::board_info::BoardInfo;
use oreboot_device::{Class, Device};
use oreboot_fdt::FdtSource;
use fdt::Fdt;

/// Architecture-specific global data
#[repr(C)]
pub struct ArchGlobalData {
    timer_rate_hz: u32,
    tbu: u32,
    tbl: u32,
    lastinc: u32,
    timer_reset_value: u32,
    tlb_fillptr: u32,
    tlb_emerg: u32,
}

impl ArchGlobalData {
    pub const fn new() -> Self {
        Self {
            timer_rate_hz: 0,
            tbu: 0,
            tbl: 0,
            lastinc: 0,
            timer_reset_value: 0,
            tlb_fillptr: 0,
            tlb_emerg: 0,
        }
    }

    pub fn timer_rate_hz(&self) -> u32 {
        self.timer_rate_hz
    }

    pub fn tbu(&self) -> u32 {
        self.tbu
    }

    pub fn tbl(&self) -> u32 {
        self.tbl
    }

    pub fn lastinc(&self) -> u32 {
        self.lastinc
    }

    pub fn timer_reset_value(&self) -> u32 {
        self.timer_reset_value
    }

    pub fn tlb_fillptr(&self) -> u32 {
        self.tlb_fillptr
    }

    pub fn tlb_emerg(&self) -> u32 {
        self.tlb_emerg
    }
}

/// Global data structure
///
/// FIXME: some fields from U-Boot are missing, especially fields behind conditional compilation
#[repr(C)]
pub struct GlobalData<'a> {
    /// board information
    bd: Option<NonNull<BoardInfo>>,
    /// Global data flags
    flags: u32,
    /// Baud rate of the serial interface
    baudrate: u32,
    /// CPU clock rate in Hz
    cpu_clk: u32,
    /// Platform clock rate in Hz
    bus_clk: u32,
    /// PCI clock rate in Hz
    /// We cannot bracket this with CONFIG_PCI due to mpc5xxx
    pci_clk: u32,
    /// Memory clock rate in Hz
    mem_clk: u32,
    /// Console is available
    ///
    /// A value of 1 indicates that serial_init() was called and a console
    /// is available.
    ///
    /// A value of 0 indicates that console input and output drivers shall
    /// not be called.
    have_console: u32,
    /// Address of environment structure
    ///
    /// @env_addr contains the address of the structure holding the
    /// environment variables.
    env_addr: u32,
    /// Environment is valid
    ///
    /// See &enum env_valid
    env_valid: u32,
    /// Bit mask indicating environment locations
    ///
    /// &enum env_location defines which bit relates to which location
    env_has_init: u32,
    /// Priority of the loaded environment
    env_load_prio: i32,
    /// Base address of RAM used by oreboot
    ram_base: u32,
    /// Top address of RAM used by oreboot
    ram_top: u64,
    /// Start address of oreboot in RAM
    ///
    /// After relocation this field indicates the address to which oreboot
    /// has been relocated. It can be displayed using the bdinfo command.
    /// Its value is needed to display the source code when debugging with
    /// GDB using the 'add-symbol-file oreboot <relocaddr>' command.
    relocaddr: u32,
    /// RAM size in bytes
    ram_size: usize,
    /// Monitor length in bytes
    mon_len: u32,
    /// IRQ stack pointer
    irq_sp: u32,
    /// Initial stack pointer address
    start_addr_sp: u32,
    /// Relocation offset
    reloc_off: u32,
    /// Pointer to relocated global data
    new_gd: Option<NonNull<GlobalData<'a>>>,
	/// root instance for Driver Model
    dm_root: Option<NonNull<Device>>,
	/// pre-allocation root instance
    dm_root_f: Option<NonNull<Device>>,
	/// Head of core tree when [`Class`]es are not in read-only memory.
	/// 
	/// When [`Class`]es are in read-only memory, [`GlobalData::class_root_s`] is not used and
	/// [`GlobalData::class_root`] points to the root node generated by dtoc.
    class_root_s: LinkedList<Class>,
	/// Pointer to head of core tree, if [`Class`]es are in read-only memory and
	/// cannot be adjusted to use [`GlobalData::class_root`] as a list head.
	///
	/// When not in read-only memory, [`GlobalData::class_root_s`] is used to hold the
	/// [`Class`] root, and [`GlobalData::class_root`] points to the address of [`GlobalData::class_root_s`].
    class_root: LinkedList<Class>,
    /// oreboot's own device tree
    fdt_blob: Option<&'static [u8]>,
    /// Relocated device tree
    new_fdt: Option<NonNull<Fdt<'a>>>,
    /// Space reserved for relocated device space
    fdt_size: u32,
    /// Source of FDT
    fdt_src: FdtSource,
    /// Buffer for env_get() before reloc
    env_buf: [u8; 32],
    /// High 32 bits of timer
    timebase_h: u32,
    /// Low 32 bits of timer
    timebase_l: u32,
    /// Current serial device
    cur_serial_dev: Option<NonNull<Device>>,
    /// Architecture-specific data
    arch: ArchGlobalData,
}

impl<'a> GlobalData<'a> {
    pub const fn new() -> Self {
        Self {
            bd: None,
            flags: 0,
            baudrate: 0,
            cpu_clk: 0,
            bus_clk: 0,
            pci_clk: 0,
            mem_clk: 0,
            have_console: 0,
            env_addr: 0,
            env_valid: 0,
            env_has_init: 0,
            env_load_prio: 0,
            ram_base: 0,
            ram_top: 0,
            relocaddr: 0,
            ram_size: 0,
            mon_len: 0,
            irq_sp: 0,
            start_addr_sp: 0,
            reloc_off: 0,
            new_gd: None,
            dm_root: None,
            dm_root_f: None,
            class_root_s: LinkedList::new(),
            class_root: LinkedList::new(),
            fdt_blob: None,
            new_fdt: None,
            fdt_size: 0,
            fdt_src: FdtSource::None,
            env_buf: [0; 32],
            timebase_h: 0,
            timebase_l: 0,
            cur_serial_dev: None,
            arch: ArchGlobalData::new(),
        }
    }

    pub fn board_info(&self) -> Option<&BoardInfo> {
        if let Some(b) = self.bd {
            Some(unsafe{ b.as_ref() })
        } else {
            None
        }
    }

    pub fn flags(&self) -> u32 {
        self.flags
    }

    pub fn baudrate(&self) -> u32 {
        self.baudrate
    }

    pub fn cpu_clk(&self) -> u32 {
        self.cpu_clk
    }

    pub fn bus_clk(&self) -> u32 {
        self.bus_clk
    }

    pub fn pci_clk(&self) -> u32 {
        self.pci_clk
    }

    pub fn mem_clk(&self) -> u32 {
        self.mem_clk
    }

    pub fn have_console(&self) -> u32 {
        self.have_console
    }

    pub fn env_addr(&self) -> u32 {
        self.env_addr
    }

    pub fn env_valid(&self) -> u32 {
        self.env_valid
    }

    pub fn env_has_init(&self) -> u32 {
        self.env_has_init
    }

    pub fn env_load_prio(&self) -> i32 {
        self.env_load_prio
    }

    pub fn ram_base(&self) -> u32 {
        self.ram_base
    }

    pub fn ram_top(&self) -> u64 {
        self.ram_top
    }

    pub fn relocaddr(&self) -> u32 {
        self.relocaddr
    }

    pub fn ram_size(&self) -> usize {
        self.ram_size
    }

    pub fn mon_len(&self) -> u32 {
        self.mon_len
    }

    pub fn irq_sp(&self) -> u32 {
        self.irq_sp
    }

    pub fn start_addr_sp(&self) -> u32 {
        self.start_addr_sp
    }

    pub fn reloc_off(&self) -> u32 {
        self.reloc_off
    }

    pub fn new_gd(&self) -> Option<&GlobalData> {
        if let Some(gd) = self.new_gd {
            Some(unsafe{ gd.as_ref() })
        } else {
            None
        }
    }

    pub fn dm_root(&self) -> Option<&Device> {
        if let Some(d) = self.dm_root {
            Some(unsafe{ d.as_ref() })
        } else if let Some(d) = self.dm_root_f {
            Some(unsafe{ d.as_ref() })
        } else {
            None
        }
    }

    pub fn class_root(&self) -> Option<&LinkedList<Class>> {
        if self.class_root.front().is_some() {
            Some(&self.class_root)
        } else if self.class_root_s.front().is_some() {
            Some(&self.class_root_s)
        } else {
            None
        }
    }

    pub fn fdt_blob(&self) -> Option<&[u8]> {
        self.fdt_blob
    }

    pub fn new_fdt(&self) -> Option<&Fdt> {
        if let Some(f) = self.new_fdt {
            Some(unsafe{ f.as_ref() })
        } else {
            None
        }
    }

    pub fn fdt_size(&self) -> u32 {
        self.fdt_size
    }

    pub fn fdt_src(&self) -> FdtSource {
        self.fdt_src
    }

    pub fn env_buf(&self) -> &[u8] {
        self.env_buf.as_ref()
    }

    pub fn timebase_h(&self) -> u32 {
        self.timebase_h
    }

    pub fn timebase_l(&self) -> u32 {
        self.timebase_l
    }

    pub fn cur_serial_dev(&self) -> Option<&Device> {
        if let Some(c) = self.cur_serial_dev {
            Some(unsafe{ c.as_ref() })
        } else {
            None
        }
    }

    pub fn arch(&self) -> &ArchGlobalData {
        &self.arch
    }
}
